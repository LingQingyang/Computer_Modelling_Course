# -*- coding: utf-8 -*-
"""Shuttlecock Flight Train.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pY3-vPbm2xt12j2ozV7gmURdYKpmNnPA
"""

import numpy as np
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import torch.nn.functional as F
device=torch.device("cuda"if torch.cuda.is_available()else"cpu")

v0=float(input("初速度(km/h)"))
height=float(input("击球点高度(m)"))
angle=float(input("击球仰角（往上为正，往下为负）(degree)"))
x_init=float(input("击球位置（击球点到底线的距离）(m)"))

#Modelling the Trajectory of a Shuttlecock
class Shuttlecock:
  def __init__(self,v0,height,angle,x_init,k=0.65,g=9.81):
    self.k,self.g=k,g
    self.t=0

    angle_rad=np.radians(angle)
    #The initial speed of the shuttlecock is inputed as km/h
    #A shuttlecock looses about half of the initial velocity,
    #imparted to it by the racket by the time it completes its turnaround.
    self.vx=v0*np.cos(angle_rad)/3.6/2
    self.vy=v0*np.sin(angle_rad)/3.6/2
    self.x,self.y=x_init,height

  def step(self,dt):
    ax=-self.k*self.vx
    ay=-self.g-self.k*self.vy

    self.vx+=ax*dt
    self.vy+=ay*dt

    self.x+=self.vx*dt
    self.y+=self.vy*dt
    self.t+=dt

  def flight_data(self,dt=0.01):
    X,Y,T=[self.x],[self.y],[self.t]
    while True:
      if self.y>=0:
        self.step(dt)
        X.append(self.x)
        Y.append(self.y)
        T.append(self.t)
      else:
        break
    return np.array(X), np.array(Y), np.array(T)

  def visualise(self,dt=0.01,label_interval=0.2):
    X,Y,T=self.flight_data()
    fig,ax=plt.subplots()
    ax.set_title("Flight of Shuttlecock (Reality)")
    ax.set_xlabel("Horizontal Displacement/m")
    ax.set_ylabel("Height/m")
    ax.set_xlim(0, 13.4)
    ax.set_ylim(0, 10)

    time_since_last_label=0
    for i in range(len(T)):
      if T[i]-time_since_last_label>=label_interval:
        ax.text(X[i], Y[i], f"{T[i]:.2f}s", fontsize=8, color="blue")
        time_since_last_label=T[i]

    ax.vlines(x=6.7, ymin=0, ymax=1.55, color='purple')
    ax.text(6.7 + 0.1, 1.55, "Net", fontsize=8, color='purple')
    ax.plot(X,Y,label="Trajectory")
    ax.plot(X[-1], Y[-1], marker='x', color='black')
    ax.text(X[-1]-0.5,Y[-1]+0.3, f"Lands at{self.t:.2f}s", fontsize=6, color='black')
    ax.legend()
    plt.show()

shuttle=Shuttlecock(v0=v0,height=height,angle=angle,x_init=x_init)
shuttle.visualise()

#Raw Data for Machines to Learn
class ShuttlecockDataset(torch.utils.data.Dataset):
  def __init__(self,n_samples=10000,max_timesteps=200,dt=0.01,device=None):
    super().__init__()
    if device is None:
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    self.device = device
    self.inputs=[]
    self.trajectories=[]
    self.max_timesteps=max_timesteps
    self.dt=dt

    for i in range(n_samples):
      v0=np.random.uniform(80, 300)
      height=np.random.uniform(0.3, 3.3)
      angle=np.random.uniform(-30, 60)
      x_init=np.random.uniform(0, 6.5)

      s=Shuttlecock(v0,height,angle,x_init)
      input_vec=np.array([v0, height, angle, x_init], dtype=np.float32)
      self.inputs.append(input_vec)


      X,Y,T=s.flight_data()
      T_new = np.linspace(0, T[-1], self.max_timesteps)
      X_new = np.interp(T_new, T, X)
      Y_new = np.interp(T_new, T, Y)
      traj=np.stack([X_new, Y_new, T_new], axis=1)
      self.trajectories.append(traj.astype(np.float32))

    self.inputs=torch.tensor(np.array(self.inputs), dtype=torch.float32).to(self.device)
    self.trajectories=torch.tensor(np.array(self.trajectories), dtype=torch.float32).to(self.device)

  def __len__(self):
    return len(self.inputs)

  def __getitem__(self, idx):
    return self.inputs[idx], self.trajectories[idx]

  def __repr__(self):
    return f"<ShuttlecockDataset size={len(self)} timesteps={self.max_timesteps}>"

dataset = ShuttlecockDataset()
#print(dataset)
x, y = dataset[0]
#print(x.shape)
#print(y.shape)

#Constructing a Multilayer Perceptron (MLP) Model
class Shuttle_Flight(nn.Module):
  def __init__(self, hidden_dim=600, output_timesteps=200):
    super().__init__()
    self.output_dim=output_timesteps*3
    self.model=nn.Sequential(
        nn.Linear(4, hidden_dim),
        nn.GELU(),
        nn.Linear(hidden_dim, hidden_dim),
        nn.LeakyReLU(0.1),
        nn.Linear(hidden_dim, hidden_dim),
        nn.GELU(),
        nn.Linear(hidden_dim, hidden_dim),
        nn.LeakyReLU(0.1),
        nn.Linear(hidden_dim, hidden_dim),
        nn.GELU(),
        nn.Linear(hidden_dim, self.output_dim)
    )

  def forward(self, x):
    out = self.model(x)  # shape: (batch_size, 600)
    return out.view(-1, 200, 3)  # shape: (batch_size, 200, 3)

from torch.utils.data import DataLoader
train_loader = DataLoader(dataset, batch_size=100, shuffle=True)

Badminton_model = Shuttle_Flight().to(device)
loss_fn = nn.MSELoss()
optimizer = torch.optim.Adam(Badminton_model.parameters(), lr=0.001)
epochs = 1000
train_losses, epoch_num = [], []

def training(Badminton_model, train_loader, optimizer, loss_fn, device, epochs):
  for epoch in range(1, epochs + 1):
    Badminton_model.train()
    running_loss = 0.0

    for batch_inputs, batch_targets in train_loader:
      # batch_inputs: shape (100, 4)
      # batch_targets: shape (100, 200, 3)

      optimizer.zero_grad()
      outputs = Badminton_model(batch_inputs)  # shape: (100, 200, 3)
      loss = loss_fn(outputs, batch_targets)
      loss.backward()
      optimizer.step()
      running_loss += loss.item()

    avg_loss = running_loss / len(train_loader)
    train_losses.append(avg_loss)
    epoch_num.append(epoch+1)

    if epoch % 100 == 0 or epoch == 1 or epoch == epochs:
      print(f"Epoch {epoch}/{epochs} - Loss: {avg_loss:.6f}")

  return Badminton_model

trained = training(Badminton_model, train_loader, optimizer, loss_fn, device, epochs)

from google.colab import drive
drive.mount('/content/drive')

torch.save(Badminton_model.state_dict(), "shuttle_flight_model.pth")
!cp shuttle_flight_model.pth /content/drive/MyDrive/AI_Models/
print("✅ Model saved as shuttle_flight_model.pth to Google Drive")

plt.plot(epoch_num, train_losses)
plt.xlabel("Epoch Number")
plt.ylabel("Training Loss (MSE)")
plt.title("Training Loss Curve")
plt.show()

with torch.no_grad():
  input_vec = torch.tensor([[v0, height, angle, x_init]], dtype=torch.float32).to(device)
  pred = Badminton_model(input_vec).squeeze(0).cpu().numpy()
  X_preds = pred[:, 0]
  Y_preds = pred[:, 1]
  T_preds = pred[:, 2]

def Predicted_Trajectory():
  fig,ax=plt.subplots()
  ax.set_title("Flight of Shuttlecock (Predicted)")
  ax.set_xlabel("Horizontal Displacement/m")
  ax.set_ylabel("Height/m")
  ax.set_xlim(0, 13.4)
  ax.set_ylim(0, 10)

  time_since_last_label=0
  for i in range(len(T_preds)):
    if T_preds[i]-time_since_last_label>=0.2:
      ax.text(X_preds[i], Y_preds[i], f"{T_preds[i]:.2f}s", fontsize=8, color="blue")
      time_since_last_label=T_preds[i]

  ax.vlines(x=6.7, ymin=0, ymax=1.55, color='purple')
  ax.text(6.7 + 0.1, 1.55, "Net", fontsize=8, color='purple')
  ax.plot(X_preds,Y_preds,label="Trajectory")
  ax.plot(X_preds[-1], Y_preds[-1], marker='x', color='black')
  ax.text(X_preds[-1]-0.5,Y_preds[-1]+0.3, f"Lands at{T_preds[-1]:.2f}s", fontsize=6, color='black')
  ax.legend()
  plt.show()

Predicted_Trajectory()